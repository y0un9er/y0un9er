<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>栈题基础</title>
      <link href="/2021/08/18/%E6%A0%88/"/>
      <url>/2021/08/18/%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="一、栈溢出"><a href="#一、栈溢出" class="headerlink" title="一、栈溢出"></a>一、栈溢出</h2><h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h3><p>​        了解栈溢出的原理</p><p>​        理清栈生长方向和溢出方向</p><p>​        了解几种基本的栈溢出利用方式</p><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p>​        函数中存储在栈中的局部变量数组边界检查不严格发生越界写，造成用户输入覆盖到缓冲区以外的数据</p><p>​        由于栈中同时存储着与函数调用参数相关信息，栈溢出可以导致控制流劫持</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">80</span>];</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">200</span>);</span><br><span class="line">    <span class="keyword">return</span>    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        func 中 buf 的长度为 80，但是可以输入 200 长度的数据，所以存在栈溢出漏洞</p><p>​        <strong>栈由高地址向低地址生长，buf 由低地址向高地址存储</strong>，所以栈溢出可以劫持函数的返回地址</p><p>​        <img src="/images/pwn/stack/1.png" alt="image-20210817101803362"></p><p>​        栈溢出基本 payload 构造：</p><p>​            <code>buf 到 rbp 长度的数据 + 一个栈的长度（rbp）+ 要跳转的地址</code></p><p>​        一般不需要构造 rbp，rbp 是程序用来定位栈中的局部变量的，除非涉及到 rbp 寄存器传递参数，一般 ROP 不需要管 rbp</p><p>​        基本利用方式：</p><p>​            ret2text：</p><p>​                程序中存在后门函数，可以直接修改返回地址为后门函数的地址</p><p>​            ret2shellcode：</p><p>​                程序中没有可利用的后门，但是有可写可执行的段，就可以将 shellcode 写入该段，然后将程序劫持到 shellcode</p><p>​            ret2libc：</p><p>​                如果拿到了 libc 中函数的地址，就可以直接调用 libc 中的函数</p><blockquote><p>​    比如通过 puts_plt(puts_got)，拿到 puts 在 libc 中的真实地址</p><p>​    然后通过 puts 的真实地址 减去 puts 在 libc 中的偏移地址 得到 libc 的基地址</p><p>​    通过 system 在 libc 的偏移地址 加上 libc 的基地址 就可以得到 system 的真实地址，用来调用 system</p></blockquote><p>​            ret2syscall：</p><p>​                把 rax 值设为系统调用表中函数对应的系统号，然后执行 syscall</p><p>​                <img src="/images/pwn/stack/2.png" alt="image-20210818100116870"></p><hr><h2 id="二、rop介绍与编写"><a href="#二、rop介绍与编写" class="headerlink" title="二、rop介绍与编写"></a>二、rop介绍与编写</h2><h3 id="重点-1"><a href="#重点-1" class="headerlink" title="重点"></a>重点</h3><p>​    了解什么是 gadget</p><p>​    了解通用 ROP 的使用</p><p>​    了解栈转移的方式</p><h3 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h3><p>​    ROP 全称 Return Oriented Programming，即返回导向编程，以一堆 ret 来完成代码逻辑，这些 ret 称之为 gadget</p><p>​    gadget 的寻找</p><p>​        ropper</p><p>​            ropper –file filename</p><p>​            ropprer –file filename –search “str”</p><p>​        ROPgadget</p><p>​            ROPgadget –binary filename</p><p>​            ROPgadget –binary filename –string “str”</p><p>​    通用 ROP</p><p>​        利用 x64 下的 __libc_csu_init 中的 gadget</p><p>​        __libc_csu_init 是对 libc 进行初始化操作的，如果程序调用了 libc，这个函数就会存在</p><p>​    </p><p>​        利用逻辑：</p><p>​            函数中存在 pop rbx、rbp、r12-15 然后 ret 的指令，意味着我们可以控制这6个寄存器</p><p>​            同时函数中存在将 r13 赋值给 rdx，r14 赋值给 rsi，r15 赋值给 edi 再 call r12+rbx*8 这样的指令</p><p>​            所以控制了 rbx、rbp、r12-15 就能调用任意函数了</p><p>​    限制了溢出长度的思路：</p><p>​        思路一：</p><p>​            寻找 one_gadget （能直接获取 shell 的指令）</p><p>​            工具</p><p>​                one_gadget </p><p>​                    安装方式：<br>​                        apt install ruby</p><p>​                        gem install one_gadget</p><p>​                    使用方式：</p><p>​                        one_gadget libc.so</p><p>​        思路二：</p><p>​            通过 pop ret 使 rsp 跑到可溢出区域外，即栈转移</p><p>​            转移到 bss 或者堆上我们提前布置好的 ROP 链开头，可以通过 mov rsp rax; ret 或者 pop rsp; ret，但实际情况下及其少见</p><p>​            方式一：（算上 rbp 和返回地址共 32 字节，只需溢出 16 字节）<br>​                <code>pop rbp; ret  +  leave; ret</code></p><p>​                rop 构造：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pop rbp; ret</span><br><span class="line"></span><br><span class="line">target stack address</span><br><span class="line"></span><br><span class="line">leave; ret</span><br></pre></td></tr></table></figure><p>​            方式二：（总 24 字节，只需溢出 8 字节）</p><p>​                通过两次 leave; ret</p><p>​                rop 构造：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target stack address</span><br><span class="line">leave; ret</span><br><span class="line">leave; ret</span><br></pre></td></tr></table></figure><p><img src="/images/pwn/stack/3.png" alt="image-20210817111812313"></p><hr><h2 id="三、改写-got-表-getshell"><a href="#三、改写-got-表-getshell" class="headerlink" title="三、改写 got 表 getshell"></a>三、改写 got 表 getshell</h2><h3 id="重点-2"><a href="#重点-2" class="headerlink" title="重点"></a>重点</h3><p>​    理解能修改 got 表调用其他函数的原因</p><p>​    了解修改 got 表的方式</p><h3 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h3><p>​    根据 elf 文件的延迟绑定机制可知，程序调用函数都是通过访问 got 表</p><p>​    将本来要执行的函数的 got 表存储的地址改为 systen 的地址，则执行该函数的时候会执行 system</p><p>​    常见用来劫持 got 表的函数，这些函数的参数一般都为用户可控</p><p>​        puts(buf)</p><p>​        atoi(buf)、atoi(buf)</p><p>​        free(buf)</p><p>​    修改 got 表的方式</p><p>​        通过 ROP，不过一般能利用 ROP 的程序不需要修改 got 表</p><p>​        任意地址写</p><p>​        bss 段负溢出（bss 段在 got 表下方的不远处）</p><h2 id="四、栈题思路"><a href="#四、栈题思路" class="headerlink" title="四、栈题思路"></a>四、栈题思路</h2><h3 id="重点-3"><a href="#重点-3" class="headerlink" title="重点"></a>重点</h3><p>​    了解栈题的解题思路</p><h3 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h3><p>​    第一步：查看文件信息（架构、32位或64位、动态编译或静态编译）</p><p>​        file filename</p><p>​        checksec filename</p><p>​            关闭了 canary 的大概率是栈题</p><p>​            开启 PIE 的要找到地址泄露的地方</p><p>​            开启 FULL RELRO 的思路就应该不是改写 got</p><p>​    第二步：分析程序逻辑</p><p>​        直接运行程序</p><p>​        丢进 ida 进行静态分析</p><p>​            把函数名、变量搞懂</p><p>​            如果有结构体，要先建立结构体</p><p>​    第三步：寻找漏洞</p><p>​        危险函数：gets、read、write、free、printf</p><p>​        如果程序有自己封装的 input 函数，重点分析有没有越界</p><p>​        看输入数据是如何处理的</p><p>​        对内存拷贝等函数要格外注意</p><p>​    第四步：漏洞利用</p><p>​        与程序逻辑和保护机制息息相关</p><p>​        需要处理的问题</p><p>​            地址问题</p><p>​                exp 离不开函数地址和 gadgets 地址</p><p>​                开启 PIE 和 ASLR，需要想办法泄露地址，泄露方法一般是让程序打印出来一些脏数据或者函数地址</p><p>​                程序基地址、堆地址、libc 基地址、栈地址并不相关</p><p>​            canary 和 NX</p><p>​                如果确认是栈题，通常考虑泄露或者修改canary</p><p>​                没有开 NX 的题，通常考虑写 shellcode</p><p>​                使用 mprotect 逃过 NX 的限制</p><p>​            程序本身限制（根据具体情况）</p><p>​                gadget 种类少</p><p>​                输入的字符有限制</p><p>​                栈溢出的字节不够</p><p>​        </p><p>​        </p>]]></content>
      
      
      <categories>
          
          <category> web狗的pwn生之路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈</title>
      <link href="/2021/08/18/%E6%A0%882/"/>
      <url>/2021/08/18/%E6%A0%882/</url>
      
        <content type="html"><![CDATA[<h1 id="《web狗的pwn生之路》系列文章目录"><a href="#《web狗的pwn生之路》系列文章目录" class="headerlink" title="《web狗的pwn生之路》系列文章目录"></a>《web狗的pwn生之路》系列文章目录</h1><p><font color=#999AAA ><a href="#">第一章 pwn 入门基础</a></p><p><font color=#999AAA >第二章 pwn 栈题基础</p><p><font color=#999AAA >待更新…………</p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><p>@<a href="%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95">TOC</a></p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>感觉没有题目的支撑，写得再多也很范范。多刷刷题再回来看这篇文章应该会有不一样的收获</p><p>师傅说格式化字符串漏洞太老了，没有讲，所以没有笔记，以后有机会补充一点</p><p>然后栈还有一些其他有意思的操作，比如说低版本的 gcc 编译的程序发生栈溢出报错回显示程序名，所以可以覆盖 argv[0]（main 函数的参数，程序名），泄露信息，知识面有限，以后再慢慢补充</p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="一、栈溢出"><a href="#一、栈溢出" class="headerlink" title="一、栈溢出"></a>一、栈溢出</h2><h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h3><pre><code>了解栈溢出的原理理清栈生长方向和溢出方向了解几种基本的栈溢出利用方式</code></pre><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><pre><code>函数中存储在栈中的局部变量数组边界检查不严格发生越界写，造成用户输入覆盖到缓冲区以外的数据由于栈中同时存储着与函数调用参数相关信息，栈溢出可以导致控制流劫持</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">80</span>];</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">200</span>);</span><br><span class="line">    <span class="keyword">return</span>    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>func 中 buf 的长度为 80，但是可以输入 200 长度的数据，所以存在栈溢出漏洞</code></pre><p><strong>栈由高地址向低地址生长，buf 由低地址向高地址存储</strong>，所以栈溢出可以劫持函数的返回地址</p><p>​        <img src="/images/pwn/stack/1.png"></p><p>​        栈溢出基本 payload 构造：</p><p>​            <code>buf 到 rbp 长度的数据 + 一个栈的长度（rbp）+ 要跳转的地址</code></p><pre><code>一般不需要构造 rbp，rbp 是程序用来定位栈中的局部变量的，除非涉及到 rbp 寄存器传递参数，一般 ROP 不需要管 rbp</code></pre><p>​    基本利用方式：</p><blockquote><p>ret2text：</p><p>程序中存在后门函数，可以直接修改返回地址为后门函数的地址<br><br>ret2shellcode：</p><p>程序中没有可利用的后门，但是有可写可执行的段，就可以将 shellcode 写入该段，然后将程序劫持到 shellcode<br><br>ret2libc：</p><p>如果拿到了 libc 中函数的地址，就可以直接调用 libc 中的函数</p><pre><code>       比如通过 puts_plt(puts_got)，拿到 puts 在 libc 中的真实地址       然后通过 puts 的真实地址 减去 puts 在 libc 中的偏移地址 得到 libc 的基地址              通过 system 在 libc 的偏移地址 加上 libc 的基地址 就可以得到 system 的真实地址，用来调用 system</code></pre><p>ret2syscall：</p><p>​                把 rax 值设为系统调用表中函数对应的系统号，然后执行 syscall</p><p>​<br><img src="/images/pwn/stack/2.png" alt="img"></p></blockquote><hr><h2 id="二、rop介绍与编写"><a href="#二、rop介绍与编写" class="headerlink" title="二、rop介绍与编写"></a>二、rop介绍与编写</h2><h3 id="重点-1"><a href="#重点-1" class="headerlink" title="重点"></a>重点</h3><pre><code>了解什么是 gadget了解通用 ROP 的使用    了解栈转移的方式</code></pre><h3 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h3><pre><code>ROP 全称 Return Oriented Programming，即返回导向编程，以一堆 ret 来完成代码逻辑，这些 ret 称之为 gadget</code></pre><p>​    gadget 的寻找</p><pre><code>ropper​    ropper --file filename​    ropprer --file filename --search &quot;str&quot;ROPgadget​    ROPgadget --binary filename​    ROPgadget --binary filename --string &quot;str&quot;</code></pre><p>​    通用 ROP</p><pre><code>利用 x64 下的 __libc_csu_init 中的 gadget</code></pre><p>__libc_csu_init 是对 libc 进行初始化操作的，如果程序调用了 libc，这个函数就会存在</p><pre><code>​    </code></pre><p>利用逻辑：</p><pre><code>​    函数中存在 pop rbx、rbp、r12-15 然后 ret 的指令，意味着我们可以控制这6个寄存器​    同时函数中存在将 r13 赋值给 rdx，r14 赋值给 rsi，r15 赋值给 edi 再 call r12+rbx*8 这样的指令​    所以控制了 rbx、rbp、r12-15 就能调用任意函数了</code></pre><p>​    限制了溢出长度的思路：</p><pre><code>思路一：寻找 one_gadget （能直接获取 shell 的指令）​    工具​        one_gadget ​            安装方式：​                apt install ruby​                gem install one_gadget​            使用方式：​                one_gadget libc.so思路二：通过 pop ret 使 rsp 跑到可溢出区域外，即栈转移转移到 bss 或者堆上我们提前布置好的 ROP 链开头，可以通过 mov rsp rax; ret 或者 pop rsp; ret，但实际情况下及其少见    方式一：（算上 rbp 和返回地址共 32 字节，只需溢出 16 字节）        pop rbp; ret  +  leave; ret​        rop 构造：            pop rbp; ret                target stack address                leave; ret​    方式二：（总 24 字节，只需溢出 8 字节）​        通过两次 leave; ret​        rop 构造：            target stack address                        leave; ret                        leave; ret</code></pre><p>两次 leave; ret 的栈布局<br><img src="/images/pwn/stack/3.png" alt="在这里插入图片描述"></p><hr><h2 id="三、改写-got-表-getshell"><a href="#三、改写-got-表-getshell" class="headerlink" title="三、改写 got 表 getshell"></a>三、改写 got 表 getshell</h2><h3 id="重点-2"><a href="#重点-2" class="headerlink" title="重点"></a>重点</h3><pre><code>理解能修改 got 表调用其他函数的原因了解修改 got 表的方式</code></pre><h3 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h3><pre><code>根据 elf 文件的延迟绑定机制可知，程序调用函数都是通过访问 got 表将本来要执行的函数的 got 表存储的地址改为 systen 的地址，则执行该函数的时候会执行 system</code></pre><p>​    常见用来劫持 got 表的函数，这些函数的参数一般都为用户可控</p><pre><code>​    puts(buf)​    atoi(buf)、atoi(buf)​    free(buf)</code></pre><p>​    修改 got 表的方式</p><pre><code>​    通过 ROP，不过一般能利用 ROP 的程序不需要修改 got 表​    任意地址写​    bss 段负溢出（bss 段在 got 表下方的不远处）</code></pre><h2 id="四、栈题思路"><a href="#四、栈题思路" class="headerlink" title="四、栈题思路"></a>四、栈题思路</h2><h3 id="重点-3"><a href="#重点-3" class="headerlink" title="重点"></a>重点</h3><pre><code> 了解栈题的解题思路</code></pre><h3 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h3><p>​    第一步：查看文件信息（架构、32位或64位、动态编译或静态编译）</p><pre><code>file filename checksec filename    关闭了 canary 的大概率是栈题         开启 PIE 的要找到地址泄露的地方        开启 FULL RELRO 的思路就应该不是改写 got</code></pre><p>​    第二步：分析程序逻辑</p><pre><code>​直接运行程序丢进 ida 进行静态分析​    把函数名、变量搞懂​    如果有结构体，要先建立结构体</code></pre><p>​    第三步：寻找漏洞</p><pre><code>​危险函数：gets、read、write、free、printf​如果程序有自己封装的 input 函数，重点分析有没有越界​看输入数据是如何处理的​对内存拷贝等函数要格外注意</code></pre><p>​    第四步：漏洞利用</p><blockquote><p>与程序逻辑和保护机制息息相关<br><br>   需要处理的问题<br><br><br>   地址问题</p><pre><code>        exp 离不开函数地址和 gadgets 地址       开启 PIE 和 ASLR，需要想办法泄露地址，泄露方法一般是让程序打印出来一些脏数据或者函数地址       程序基地址、堆地址、libc 基地址、栈地址并不相关</code></pre><p><br>​            canary 和 NX</p><pre><code>   如果确认是栈题，通常考虑泄露或者修改canary    没有开 NX 的题，通常考虑写 shellcode    使用 mprotect 逃过 NX 的限制</code></pre><p><br>​            程序本身限制（根据具体情况分析）</p><pre><code>   gadget 种类少    输入的字符有限制    栈溢出的字节不够</code></pre></blockquote><p>​        </p><p>​        </p>]]></content>
      
      
      <categories>
          
          <category> web狗的pwn生之路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn基础</title>
      <link href="/2021/08/18/pwn%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/08/18/pwn%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="pwn-基础"><a href="#pwn-基础" class="headerlink" title="pwn 基础"></a>pwn 基础</h1><p>[toc]</p><hr><h2 id="汇编基础"><a href="#汇编基础" class="headerlink" title="汇编基础"></a>汇编基础</h2><h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h3><p>​    各寄存器的作用</p><p>​    常用汇编指令的使用</p><p>​    各寄存器的作用</p><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><p>​    主流操作系统中，都是以字节（B）为寻址单位</p><p>​    计算机真正能运行的是二进制形式的机器码，一般以16进制呈现</p><p>​    汇编语言就是机器码的助记符</p><p>​    <strong>通用寄存器</strong>：</p><p>​        RAX、RBX、RCX、RDX、RDI、RSI、R8、R9、R10、R11、R12、R13、R14、R15</p><p>​        RAX（RBX、RCX、RDX）向下兼容规则：</p><p>​            低 32 位：EAX</p><p>​            低 16 位：AX</p><p>​            低 16 位中的高 8 位：AH</p><p>​            低 8 位：AL</p><p>​        RDI（RSI、RSP）向下兼容规则：</p><p>​            低 32 位：EDI</p><p>​        R8（R9、R10、R11、R12、R13、R14、R15）向下兼容规则：</p><p>​            低 32 位：R8d</p><p>​            低 16 位：R8W</p><p>​            低 8 位：R8B</p><p>​    <strong>栈顶指针</strong>：RSP</p><p>​    <strong>栈底指针</strong>：RBP</p><p>​        栈顶指针 与 栈底指针 用于维护程序运行时的函数栈</p><p>​    <strong>标志寄存器</strong>：EFLAGS</p><p>​        包括：AF、PF、SF、ZF、OF、CF 等标识位</p><p>​    <strong>指令寄存器</strong>：RIP</p><p>​        正常情况下，不能直接修改，每次运行一条指令自增一条指令长度</p><p>​        若要修改，可通过 call、jmp、ret 等跳转指令</p><p>​    <strong>汇编寻址</strong>（加中括号的是地址）</p><table><thead><tr><th align="center">寻址方式</th><th align="center">表示</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">立即寻址</td><td align="center">1234h</td><td align="center">1234h数值本身</td></tr><tr><td align="center">直接寻址</td><td align="center">[1234h]</td><td align="center">地址1234h</td></tr><tr><td align="center">寄存器寻址</td><td align="center">RAX</td><td align="center">RAX寄存器存的值</td></tr><tr><td align="center">寄存器间接寻址</td><td align="center">[RAX]</td><td align="center">RAX存的地址</td></tr><tr><td align="center">变址寻址</td><td align="center">[RAX + 1234h]</td><td align="center">RAX存的值 + 1234h 这个地址</td></tr></tbody></table><p>​    <strong>汇编指令</strong>（分为 intel 和 AT&amp;T)</p><table><thead><tr><th align="center">指令</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">mov rax rbx</td><td align="center">将 rbx 的值赋给 rax</td></tr><tr><td align="center">lea rax [rbx]</td><td align="center">将 rbx 这个地址赋给 rax，同上</td></tr><tr><td align="center">add rax rbx</td><td align="center">rax + rbx</td></tr><tr><td align="center">sub rax rbx</td><td align="center">rax - rbx</td></tr><tr><td align="center">and rax rbx</td><td align="center">rax &amp; rbx</td></tr><tr><td align="center">xor rax rbx</td><td align="center">rax ^ rbx</td></tr><tr><td align="center">call 1234h</td><td align="center">执行地址 1234h 处的函数</td></tr><tr><td align="center">ret</td><td align="center">函数返回</td></tr><tr><td align="center">cmp rax rbx</td><td align="center">比较 rax 与 rbx，保存至 EFLAGS 寄存器</td></tr><tr><td align="center">jmp 1234h</td><td align="center">使 rip = 1234h，无条件跳转到 1234h</td></tr><tr><td align="center">push rax</td><td align="center">将 rax 存储到栈顶</td></tr><tr><td align="center">pop rax</td><td align="center">将栈顶的值赋给 rax，rsp+8</td></tr><tr><td align="center">xchg rax rbx</td><td align="center">交换 rax、rbx 的值</td></tr></tbody></table><p>​    <strong>call 与 jmp 的异同</strong>：</p><p>​        call 与 jmp 都是跳转到一个地址</p><p>​        但是 call 会执行该地址处的函数，jmp 只跳转</p><h2 id="Linux-基础"><a href="#Linux-基础" class="headerlink" title="Linux 基础"></a>Linux 基础</h2><h3 id="重点-1"><a href="#重点-1" class="headerlink" title="重点"></a>重点</h3><p>​    大端序、小端序在计算机中的存储方式</p><p>​    理解栈的结构</p><h3 id="笔记-1"><a href="#笔记-1" class="headerlink" title="笔记"></a>笔记</h3><p>​    虚拟内存是物理内存经过MUU（内存转换单元）转换后的地址（页表）</p><blockquote><p>文件偏移地址 = 虚拟内存地址（VA）- 装载基址（Image Base）- 节偏移</p><p>节偏移 = 虚拟偏移 - 原始偏移</p></blockquote><p>​    <strong>小端序</strong></p><p>​        记忆口诀：高高低低</p><p>​        数据高位存储在计算机地址的高位</p><p>​    <strong>大端序</strong></p><p>​        记忆口诀：高低低高</p><p>​        数据高位存储在计算机地址的低位</p><p>​    Linux 数据存储的格式是　小端序</p><p>​    文件描述符：</p><p>​        Linux 中，一切都是文件</p><p>​        0：标准输入、1：标准输出、2：标准错误</p><p>​    <strong>栈</strong></p><p>​        栈是一种先进后出的数据结构，只有 push（压栈）和 pop（弹栈）两种操作</p><p>​        由于函数调用顺序也是　LIFO，所以我们能接触到的绝大多数系统都是通过栈来维护函数调用关系</p><p>​        在　Linux　中，系统为每个进程都安排了一个栈，进程中每一个调用的函数都有自己独立的栈帧，栈由高地址向低地址生长</p><h2 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a>调用约定</h2><h3 id="重点-2"><a href="#重点-2" class="headerlink" title="重点"></a>重点</h3><p>​    了解函数调用相关的汇编指令</p><p>​    理解是函数调用过程中是如何维护栈平衡的</p><h3 id="笔记-2"><a href="#笔记-2" class="headerlink" title="笔记"></a>笔记</h3><p>​    pop：</p><p>​        pop 指令的作用是弹栈，将栈顶的数据弹出到寄存器，然后栈顶的指针向下移动一个单位</p><p>​        pop rax    =========&gt;    mov rax [rsp]; add rsp 8</p><p>​    push：</p><p>​        push 指令的作用是压栈，将栈顶指针向上移动一个单位，然后将一个寄存器的值存放在栈顶</p><p>​        push rax    =========&gt;    sub rsp 8; mov [rsp] rax; </p><p>​    jmp：</p><p>​        立即跳转，不涉及函数调用，用于循环，类似高级语言 if 产生的跳转</p><p>​        jmp 123h    =========&gt;    mov rip 123h</p><p>​    call：</p><p>​        函数调用，需要保存返回地址</p><p>​        call 123h    =========&gt;    push rip; mov rip 123h</p><p>​    ret：</p><p>​        用于函数返回</p><p>​        ret    =========&gt;    pop rip</p><p>​    leave：</p><p>​        作用是维护栈帧，通常出现在函数的结尾。与 ret 连用</p><p>​        leve    =========&gt;    mov rsp rbp; pop rbp</p><p>​    在调用函数的时候，rip 指针指向调用函数的下一条指令</p><p>​    被调用函数需要维护栈帧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push rbp</span><br><span class="line">mov rbp rsp</span><br><span class="line">sub rsp xxx# 开启被调用函数的栈帧，xxx 为栈帧的大小</span><br></pre></td></tr></table></figure><p>​    </p><p>​    栈帧的维护就是维护 rbp 和 rsp 两个指针</p><p>​        rsp 永远指向栈顶</p><p>​        rbp 用来定位局部变量</p><p>​    </p><p>​    函数的返回值会存储到 <strong>rax</strong> 寄存器</p><p>​    </p><p>​    64 程序传参规则：</p><p>​        从左至右参数依次传递给 rdi、rsi、rdx、rcx、r8、r9</p><p>​        多于6个参数，后面的参数 从右至左依次压入栈中传递</p><p>​    syscall：</p><p>​        用于调用系统函数，调用时需要指明系统调用号</p><p>​        将系统调用号保存在 rax 寄存器中，然后布置好参数，即可执行 syscall </p><p><img src="/images/pwn/base/1.png"></p><p>​        如：调用 read(0, buf, size)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov rax 0;</span><br><span class="line">mov rdi 0;</span><br><span class="line">mov rsi buf;</span><br><span class="line">mov rdx size;</span><br><span class="line">syscall;</span><br></pre></td></tr></table></figure><h2 id="ELF-文件结构"><a href="#ELF-文件结构" class="headerlink" title="ELF 文件结构"></a>ELF 文件结构</h2><h3 id="重点-3"><a href="#重点-3" class="headerlink" title="重点"></a>重点</h3><p>​    了解 elf 文件的节信息</p><h3 id="笔记-3"><a href="#笔记-3" class="headerlink" title="笔记"></a>笔记</h3><p>​    elf 是 Linux 中的二进制可执行文件</p><p>​    elf 的基本信息存在与 elf 的头部信息中，这些信息包括指令的允许架构、程序的入口等内容</p><p>​    通过 readelf -h <elf_name> 来查看头部信息</p><p>​    elf 包括许多节，各节存放不同数据，这些节的信息存放在节头表中，可以通过 readelf -s <elf_name> 查看</p><table><thead><tr><th align="center">节名</th><th align="center">存放的数据</th></tr></thead><tbody><tr><td align="center">.text</td><td align="center">存放程序运行的代码</td></tr><tr><td align="center">.rdata</td><td align="center">存放一些如字符串等不可修改的数据</td></tr><tr><td align="center">.data</td><td align="center">存放一些已经初始化的可修改的数据</td></tr><tr><td align="center">.bss</td><td align="center">存放未被初始化的程序可修改的数据</td></tr><tr><td align="center">.plt 与 .got</td><td align="center">程序动态链接函数地址</td></tr></tbody></table><p>​    elf 文件的节会被映射进内存中的段，映射机制是根据节的权限来进行映射的，可读可写的节被映射入一个段，只读的节被映射入一个段</p><h2 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h2><h3 id="重点-4"><a href="#重点-4" class="headerlink" title="重点"></a>重点</h3><p>​    了解什么是延迟绑定机制</p><p>​    了解 plt 与 got 的表的结构与作用 </p><h3 id="笔记-4"><a href="#笔记-4" class="headerlink" title="笔记"></a>笔记</h3><p>​    一个程序运行过程中可能会调用很多函数，但是在一次运行中并不能保证全部被调用</p><p>​    <strong>静态编译</strong>：</p><p>​        将所有可能运行到的库函数一同编译到可执行文件中</p><p>​        优点：不需要依赖动态链接库，适用于程序使用的动态链接库比较特殊</p><p>​        缺点：体积很大，编译速度很慢</p><p>​    <strong>动态编译</strong>：</p><p>​        遇到需要调用的库函数时再去动态链接库中寻找</p><p>​        优点：缩小了文件体积，加快了编译速度</p><p>​        缺点：会附带庞大的链接库；若计算机没安装对应库，则程序不能正常运行</p><p>​    PLT：</p><p>​        程序链接表，用于延迟绑定</p><p>​    GOT：</p><p>​        全局偏移表</p><p>​        ELF 中有两个 got 表，分别为 .got 和 .plt.got，前者用于全局变量的引用地址，后者用于保存函数的引用地址</p><p><strong>不管是程序第几次调用外部函数，程真正调用的是 plt 表</strong></p><p>第一次调用：</p><blockquote><p>plt 表会跳到对应的 got 表</p><p>此时 got 表存的是 plt 表的一段指令的地址，其作用是准备一些参数进行动态解析</p><p>之后会跳到 plt 的表头，表头的内容是动态解析函数，将目标地址存入 got 表</p></blockquote><p>之后的调用</p><blockquote><p>plt 表跳到对应的 got 表</p><p>got 表存的是目标地址，直接跳转到该地址</p></blockquote><p><img src="/images/pwn/base/2.png"></p><p>​        </p><h2 id="Linux-保护机制"><a href="#Linux-保护机制" class="headerlink" title="Linux 保护机制"></a>Linux 保护机制</h2><h3 id="重点-5"><a href="#重点-5" class="headerlink" title="重点"></a>重点</h3><p>​    了解各种保护机制的实现方式和产生的效果</p><p>​    学会各种保护机制的基本绕过方式</p><h3 id="笔记-5"><a href="#笔记-5" class="headerlink" title="笔记"></a>笔记</h3><p>​    <strong>canary</strong>：<br>​        用来判断程序的执行环境，主要针对栈溢出</p><p>​        开头为 \x00 的八字节随机数，随机数本体会存放于 fs 段偏移为 0x28 的区域</p><p>​        在函数调用中，程序都会将这段随机数存放于栈底，每次运行结束返回时，都会将这一随机数与本体进行对比</p><p>​        绕过方式：</p><p>​            修改 canary</p><p>​            泄露 canary</p><p>​    <strong>NX（Not Executable）</strong>：</p><p>​        使程序中的堆、栈、bss段 等可写的段不可执行，导致不能执行我们自己编写的 shellcode</p><p>​        绕过方式：</p><p>​            用 mprotect 函数来改写段的权限</p><p>​            对于 rop 或 劫持got表 等利用方式不受影响</p><p>​    <strong>PIE 和 ASLR</strong>：</p><p>​        PIE 指的是 程序内存加载基地址随机化，不能一下子确定程序的基地址</p><p>​        ASLR 是 使程序运行动态链接库、栈等地址随机化</p><p>​        绕过方式：</p><p>​            泄露函数地址，通过偏移确定基地址</p><p>​    <strong>RELRO</strong>：</p><p>​        主要针对延迟绑定机制，使 got 表这种和函数动态链接相关的内存地址，对用户只读，意味着不能劫持 got 表中的函数指针</p><p>​    gcc 编译时关闭程序保护：</p><p>​        PIE：gcc -no-pie</p><p>​        ASLR：</p><p>​            查看：cat  /proc/sys/kernel/randomize_va_space</p><p>​            关闭： echo 0 &gt; /proc/sys/kernel/randomize_va_space</p><p>​        RELRO：-z norelro</p><p>​        canary：-fno-stack-protector</p><p>​        NX：-z execstack</p><h2 id="常用工具的使用"><a href="#常用工具的使用" class="headerlink" title="常用工具的使用"></a>常用工具的使用</h2><h3 id="重点-6"><a href="#重点-6" class="headerlink" title="重点"></a>重点</h3><p>​    了解 IDA 静态调试的基本技巧</p><p>​    了解 gdb 动态调试的基本技巧</p><p>​    掌握 pwnttools 的使用</p><h3 id="笔记-6"><a href="#笔记-6" class="headerlink" title="笔记"></a>笔记</h3><p>​    IDA：</p><p>​        start 是程序真正的入口，它调用了 __libc_start_main，而 __libc_start_main 的第一个参数正是我们的 main 函数</p><p>​        如果 IDA 没有识别出 main 函数，可以先找到 start，start 一定可以识别出来</p><p>​        遇到不明白的函数，可以在 linux 中使用 man 命令查看函数的使用手册</p><p>​        快键键：    </p><table><thead><tr><th align="center">快键键</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">h</td><td align="center">转 10 进制与 16 进制</td></tr><tr><td align="center">r</td><td align="center">转字符</td></tr><tr><td align="center">x</td><td align="center">查看交叉引用</td></tr><tr><td align="center">y</td><td align="center">改变变量和函数返回值的类型</td></tr><tr><td align="center">选择一段数据，按 shift + e</td><td align="center">dump 出一段字符串</td></tr><tr><td align="center">TAB</td><td align="center">转换汇编窗口和伪代码窗口</td></tr><tr><td align="center">空格</td><td align="center">转换两种汇编显示形式</td></tr></tbody></table><p>​    gdb：</p><p>​        使用 gdb file_name 启动 gdb 或者 进入 gdb 后使用 file file_name 加载程序</p><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">b *地址</td><td align="center">在该地址处下断点</td></tr><tr><td align="center">info b</td><td align="center">查看断点信息</td></tr><tr><td align="center">info r</td><td align="center">查看寄存器的值</td></tr><tr><td align="center">vmmap</td><td align="center">查看内存的布局</td></tr><tr><td align="center">x/100gx 地址</td><td align="center">以 16 进行格式查看 100 个四字数据（w 字、g 四字）</td></tr><tr><td align="center">x/8i 地址</td><td align="center">以指令的形式打印内存数据</td></tr><tr><td align="center">x/s 地址</td><td align="center">以字符串的形式查看地址存的数据</td></tr><tr><td align="center">p &amp;__malloc_hook</td><td align="center">查看 __malloc_hook 的地址</td></tr><tr><td align="center">p __malloc_hook</td><td align="center">查看 __malloc_hook 的数据</td></tr><tr><td align="center">p/x 0x100 - 20</td><td align="center">计算 0x100-20 并以 16 进制打印</td></tr><tr><td align="center">search ‘/bin/sh’</td><td align="center">查看内存的字符串</td></tr><tr><td align="center">stack 20</td><td align="center">查看栈上20个数据</td></tr><tr><td align="center">bt 或 backtrace</td><td align="center">函数调用栈</td></tr><tr><td align="center">si</td><td align="center">单步步入</td></tr><tr><td align="center">ni</td><td align="center">单步不过</td></tr><tr><td align="center">c</td><td align="center">从当前位置执行到断点处</td></tr><tr><td align="center">r</td><td align="center">从程序开始执行到断点处</td></tr><tr><td align="center">finish</td><td align="center">执行到当前函数的完</td></tr></tbody></table><p>pwntools：</p><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">from pwn import *</td><td align="center">导入 pwntools 的包</td></tr><tr><td align="center">p = process(‘file’, env={‘LD_PRELOAD’: ‘libc’})</td><td align="center">加载本地程序，并指定程序使用的 libc</td></tr><tr><td align="center">r = remote(‘ip’, port)</td><td align="center">加载远程程序</td></tr><tr><td align="center">p.recv()</td><td align="center">接收程序传回的数据，可以添加整数参数，表示接收数据的大小</td></tr><tr><td align="center">p.recvuntil(‘str’)</td><td align="center">接收数据，直到接收完出现所给字符串为止，如果没有出现，程序会挂起</td></tr><tr><td align="center">p.send(‘str’)</td><td align="center">发送数据，末尾没有结束符</td></tr><tr><td align="center">p.sendline(‘str’)</td><td align="center">发送数据，末尾有结束符</td></tr><tr><td align="center">p.sendafter(‘str1’,  ‘str2’)</td><td align="center">recvuntil(‘str1’) 与 send(‘str2’) 的合体版</td></tr><tr><td align="center">gdb.attach(p, ‘指令’)</td><td align="center">启动 gdb 调试程序，并且启动前执行指令，多条指令可以使用 \n 分隔</td></tr><tr><td align="center">p.interactive()</td><td align="center">启动交互模式，可以使脚本执行完程序不退出</td></tr><tr><td align="center">p64、32、16、8</td><td align="center">将数据转为8、4、2、1字节的机器码</td></tr><tr><td align="center">u64、32、16、8</td><td align="center">将机器码进行解码</td></tr></tbody></table><p>​    </p><p>​    脚本模板：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>  *</span><br><span class="line"></span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, binary=<span class="string">&#x27;file&#x27;</span>, arch=<span class="string">&#x27;i386&#x27;</span>, terminal=[<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;sp&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>])<span class="comment"># arch 为文件的架构，分为 amd64 和 i386</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;file&#x27;</span>, env=&#123;<span class="string">&#x27;LD_PRELOAD&#x27;</span>: <span class="string">&#x27;libc.so&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web狗的pwn生之路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>images</title>
      <link href="/2021/08/18/images/"/>
      <url>/2021/08/18/images/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
